//
//  GreetingViewModel.swift
//  MyGreetingApp
//
//  Created by Денис Гиндулин on 18.02.2024.
//

// создал протокол, который будет публичным интерфейсом для класса GreetingViewModel, то есть для архитектурного модуля View-Model из архитектурного паттерна MVVM (Model - View - View-Model). Имя протокола сложил из трех компонентов: 1. имя сцены (Greeting); 2. имя архитектурного модуля (или класса, который будет подписываться под протокол) (ViewModel); 3. слово Protocol. Классы GreetingViewController и GreetingViewModel будут ссылаться друг на друга, поэтому между ними будет образовываться цикл сильных ссылок, который надо будет разорвать, сделав одну из ссылок unowned (см. файл GreetingViewController).
protocol GreetingViewModelProtocol {
    // объявляю свойство greeting и в фигурных скобках указываю, что свойство является геттером ({ get }), то есть я буду следить за его состояние (за первичным получением и изменениями его значения). Когда состояние будет обновляться, будет реагирование на это.
    var greeting: String? { get }
    // объявляю свойство greetingDidChange (переводится как: приветствие было изменено) и в фигурных скобках указываю, что свойство является геттером и сеттером ({ get set }), то есть буду и считывать его значени и устанавливать (при инициализации). Это свойство - коллбэк (callback), за счет которого образуется Data binding (связывание данных), то есть callback - это замыкание, которое принимает в качестве параметра сам тип протокола (GreetingViewModelProtocol) и ничего не возвращает (это выражаю с помощью -> Void). Суть замыкания в том, чтобы вернуть обновленное состояние модели представления всякий раз, когда произойдет определенного рода событие. В этом случае событием будет изменение значения свойства greeting. А именно: когда значение свойства greeting поменяется, я вызову этот блок замыкания greetingDidChange и помещу в него обновленный объект класса GreetingViewModel. Блок замыкания будет раскрываться во View Controller (см. файл GreetingViewController).
    var greetingDidChange: ((GreetingViewModelProtocol) -> Void)? { get set }
    // требование протокола реализовать обязательный инициализатор. Это инициализатор протокола, поэтому здесь только имя инициализатора и параметр person с указанием типа Person в круглых скобках, а реализации инициализатора нет (нет фигурных скобок). Реализация будет в классе, который подпишется под этот протокол.
    init(person: Person)
    // требование протокола реализовать метод. Это метод протокола, поэтому здесь только имя метода в круглых скобках, а реализации метода нет (нет фигурных скобок). Реализация будет в классе, который подпишется под этот протокол.
    func showGreeting()
}

// это архитектурный модуль View-Model архитектурного паттерна MVVM (Model - View - View-Model), представляющий собой класс GreetingViewModel, который подписываю под протокол GreetingViewModelProtocol
class GreetingViewModel: GreetingViewModelProtocol {
    // исходя из требований протокола GreetingViewModelProtocol, объявляю свойство greeting и указываю его тип (String? - вопросительный знак показывается, что это опциональный тип). Внутри свойства (в фигурных скобках) указываю ключевое слово didSet, что позволяет следить за изменением состояния свойства greeting. Когда свойство greeting будет меняться (инициализироваться - получать первичное значение при подготовке его к использованию, либо при изменение значения), каждый раз будет срабатывать didSet (точнее блок кода, написанный внутри фигурных скобок после него), то есть будет вызван блок замыкания (коллбэк greetingDidChange)
    var greeting: String? {
        didSet {
            // при вызове блок замыкания принимает тип GreetingViewModelProtocol, поэтому указываю на это ключевым словом self. Так как класс GreetingViewModel подписан под протокол GreetingViewModelProtocol, то написав self, я помещаю экземпляр класса GreetingViewModel целиком в блок замыкания greetingDidChange.
            greetingDidChange?(self)
        }
    }
    // исходя из требований протокола GreetingViewModelProtocol, объявляю свойство greetingDidChange, чтобы определить блок замыкания, и никак его не инициализирую, так как инициализация происходит в didSet строкой выше.
    var greetingDidChange: ((GreetingViewModelProtocol) -> Void)?
    
    // для того, чтобы строкой ниже реализовать обязательный (предусмотренный протоколом GreetingViewModelProtocol) инициализатор, объявляю здесь в классе GreetingViewModel свойство person и указываю его тип - Person. Использовал ключевое слово private, чтобы ограничить доступ к свойству person откуда-либо вне пределов класса GreetingViewModel.
    private let person: Person
    
    // это обязательный инициализатор. С помощью него создается связь архитектурного модуля View-Model с архитектурным модулем Model. В результате свойство person класса GreetingViewModel получит в качестве значения person из структуры Person. Это необходимо, чтобы позже в этом классе реализовать метод showGreeting.
    required init(person: Person) {
        self.person = person
    }
    
    // это реализация метода showGreeting. Суть: инициализировать (подготовить, наполнив стартовым значением) объект приветствия (фразу "Hello, ...!"). Реализовать метод надо, исходя из требований протокола GreetingViewModelProtocol. Вызывать этот метод буду в классе GreetingViewController в рамках переопределения метода touchesBegan, который срабатывает при касании пользователем экрана устройства. То есть модуль View не готовит приветственную фразу, этим занимается View-Model. Из-за того, что в методе showGreeting происходит изменение состояния свойства greeting (а именно: ему присваивается стартовое значение), будет происходить вызов didSet (вызов обёрвера), который будет проявляться в том, что происходит вызов коллбэка greetingDidChange (а именно: в блок замыкания будет помещен экземпляр класса GreetingViewModel целиком, включая это новое значение свойства greeting). В файле GreetingViewController в классе GreetingViewController, представляющем собой архитектурный модуль View, будет раскрыт блок замыкания greetingDidChange. В момент раскрытия (разворачивания) блок замыкания вернет мне экземпляр класса GreetingViewModel, через который появится доступ к свойству greeting с его обновленным значением и к свойству person, которое тоже участвует в формировании фразы приветствия.
    func showGreeting() {
        // создаю объект приветствия. Данные для него архитектурный модуль View-Model берет из архитектурного модуля Model, обращаясь к свойствам name и surname экземпляра структуры Person.
        greeting = "Hello, \(person.name) \(person.surname)!"
    }
}
